// **********************************************************************************
// * Copyright (c) 2013 Robin Murray
// **********************************************************************************
// *
// * File: astParser.cs
// *
// * Description:  Abstract syntax tree parser
// *
// * Generated By: JavaCC - astParser.java
// *
// **********************************************************************************
// *
// * Granting License: The MIT License (MIT)
// * 
// *   Permission is hereby granted, free of charge, to any person obtaining a copy
// *   of this software and associated documentation files (the "Software"), to deal
// *   in the Software without restriction, including without limitation the rights
// *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// *   copies of the Software, and to permit persons to whom the Software is
// *   furnished to do so, subject to the following conditions:
// *   The above copyright notice and this permission notice shall be included in
// *   all copies or substantial portions of the Software.
// *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// *   THE SOFTWARE.
// * 
// **********************************************************************************

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

using DemiTasse.ast;
using DemiTasse.psrutil;

// **********************************************************************************
// * Implementation
// **********************************************************************************

namespace DemiTasse.astpsr
{
    public class AstParser : AstParserConstants
    {
        static /* final */ public AstProgram Program() /* throws ParseException */
        {
            AstClassDeclList cl;
            jj_consume_token(AstRegExpId.kw56);
            jj_consume_token(AstRegExpId.kwProgram);
            cl = astClassDeclList();
            jj_consume_token(AstRegExpId.kw57);
            jj_consume_token((AstRegExpId)0);
            
            // {if (true) return new Program(cl);}
            // throw new Error("Missing return statement in function");

            return new AstProgram(cl);
        }

        static /* final */ public AstClassDeclList astClassDeclList() /* throws ParseException */
        {
            bool done = false;
            AstClassDecl c; AstClassDeclList cl = new AstClassDeclList();
            jj_consume_token(AstRegExpId.kw56);
            jj_consume_token(AstRegExpId.kwClassDeclList);
            // label_1:
            while (!done)
            {
                switch ((jj_ntk == AstRegExpId.UNDEFINED)?jj_ntk_fn():jj_ntk)
                {
                    case AstRegExpId.kw56:
                        ;
                        break;
                    
                    default:
                        jj_la1[0] = jj_gen;
                        done = true;
                        //break label_1;
                        break;
                }

                if (!done)
                {
                    c = astClassDecl();
                    cl.Add(c);
                }
            }

            jj_consume_token(AstRegExpId.kw57);
            {if (true) return cl;}
            throw new Error("Missing return statement in function");
        }

        static /* final */ public AstClassDecl astClassDecl() /* throws ParseException */
        {
            AstExp e1, e2; AstVarDeclList vl; AstMethodDeclList ml;

            jj_consume_token(AstParserConstants.AstRegExpId.kw56);
            jj_consume_token(AstRegExpId.kwClassDecl);

            e1 = astExp();
            e2 = astExp();
            vl = astVarDeclList();
            ml = astMethodDeclList();
            jj_consume_token(AstRegExpId.kw57);

            {if (true) return new AstClassDecl((AstId)e1,(AstId)e2,vl,ml);}
            throw new Error("Missing return statement in function");
        }

        static /* final */ public AstVarDeclList astVarDeclList() /* throws ParseException */
        {
            AstVarDecl v;
            AstVarDeclList vl = new AstVarDeclList();
            bool done = false;

            jj_consume_token(AstRegExpId.kw56);
            jj_consume_token(AstRegExpId.kwVarDeclList);
            
            // label_2:
            while (!done)
            {
                switch ((jj_ntk == AstRegExpId.UNDEFINED)?jj_ntk_fn():jj_ntk)
                {
                    case AstRegExpId.kw56:

                        break;

                    default:

                        jj_la1[1] = jj_gen;
                        done = true;
                        break;
                }

                if (!done)
                {
                    v = astVarDecl();
                    vl.Add(v);
                }
            }


            jj_consume_token(AstParserConstants.AstRegExpId.kw57);
            {if (true) return vl;}
            throw new Error("Missing return statement in function");
        }

        static /* final */ public AstVarDecl astVarDecl() /* throws ParseException */
        {
            ast.AstType t; AstExp e1, e2;
            jj_consume_token(AstRegExpId.kw56);
            jj_consume_token(AstRegExpId.kwVarDecl);
            t = astType();
            e1 = astExp();
            e2 = astExp();
            jj_consume_token(AstRegExpId.kw57);
            {if (true) return new AstVarDecl(t,(AstId)e1,e2);}
            throw new Error("Missing return statement in function");
        }

        static /* final */ public AstMethodDeclList astMethodDeclList() /* throws ParseException */
        {
            AstMethodDecl m; 
            AstMethodDeclList ml = new AstMethodDeclList();
            bool done = false;

            jj_consume_token(AstRegExpId.kw56);
            jj_consume_token(AstRegExpId.kwMethodDeclList);
            
            // label_3:
            while (!done)
            {
                switch ((jj_ntk == AstRegExpId.UNDEFINED)?jj_ntk_fn():jj_ntk)
                {
                    case AstRegExpId.kw56:
                        break;
                default:
                    jj_la1[2] = jj_gen;
                    done = true;
                    break /* label_3 */;
                }
                if (!done)
                {
                    m = astMethodDecl();
                    ml.Add(m);
                }
            }
            jj_consume_token(AstRegExpId.kw57);
            {if (true) return ml;}
            throw new Error("Missing return statement in function");
        }

        static /* final */ public AstMethodDecl astMethodDecl() /* throws ParseException */
        {
            AstType t; 
            AstExp e; 
            AstFormalList fl; 
            AstVarDeclList vl; 
            AstStmtList sl;
            
            jj_consume_token(AstRegExpId.kw56);
            jj_consume_token(AstRegExpId.kwMethodDecl);

            t = astType();
            e = astExp();
            fl = astFormalList();
            vl = astVarDeclList();
            sl = astStmtList();
            jj_consume_token(AstRegExpId.kw57);
            {if (true) return new AstMethodDecl(t,(AstId)e,fl,vl,sl);}
            throw new Error("Missing return statement in function");
        }

        static /* final */ public AstFormalList astFormalList() /* throws ParseException */
        {
            AstFormal f; AstFormalList fl = new AstFormalList();
            bool done = false;

            jj_consume_token(AstRegExpId.kw56);
            jj_consume_token(AstRegExpId.kwFormalList);

            //label_4:
            while (!done) 
            {
                switch ((jj_ntk == AstRegExpId.UNDEFINED)?jj_ntk_fn():jj_ntk)
                {
                    case AstRegExpId.kw56:
                        break;

                    default:
                        jj_la1[3] = jj_gen;
                        done = true;
                        break /* label_4 */;
                }
                if (!done)
                {
                    f = astFormal();
                    fl.Add(f);
                }
            }

            jj_consume_token(AstRegExpId.kw57);
            {if (true) return fl;}
            throw new Error("Missing return statement in function");
        }

        static /* final */ public AstFormal astFormal() /* throws ParseException */
        {
            ast.AstType t; AstExp e;
            jj_consume_token(AstRegExpId.kw56);
            jj_consume_token(AstRegExpId.kwFormal);
            t = astType();
            e = astExp();
            jj_consume_token(AstRegExpId.kw57);
            {if (true) return new AstFormal(t,(AstId)e);}
            throw new Error("Missing return statement in function");
        }

        static /* final */ public AstStmtList astStmtList() /* throws ParseException */
        {
            AstStmt s; AstStmtList sl = new AstStmtList(); bool done = false;

            jj_consume_token(AstRegExpId.kw56);
            jj_consume_token(AstRegExpId.kwStmtList);

            //label_5:
            while (!done)
            {
                switch ((jj_ntk == AstRegExpId.UNDEFINED)?jj_ntk_fn():jj_ntk)
                {
                    case AstRegExpId.kw56:
                        break;
                    default:
                        jj_la1[4] = jj_gen;
                        done = true;
                        break /* label_5 */;
                }

                if (!done)
                {
                    s = astStmt();
                    sl.Add(s);
                }
            }
            jj_consume_token(AstRegExpId.kw57);
            {if (true) return sl;}
            throw new Error("Missing return statement in function");
        }

        static /* final */ public AstExpList astExpList() /* throws ParseException */
        {
            AstExp e; AstExpList el = new AstExpList(); bool done = false;

            jj_consume_token(AstRegExpId.kw56);
            jj_consume_token(AstRegExpId.kwExpList);
            
            //label_6:
            while (!done)
            {
                switch ((jj_ntk == AstRegExpId.UNDEFINED) ? jj_ntk_fn() : jj_ntk)
                {
                    case AstRegExpId.kw56:
                        break;
                    default:
                        jj_la1[5] = jj_gen;
                        done = true;
                        break /* label_6*/ ;
                }
                if (!done)
                {
                    e = astExp();
                    el.Add(e);
                }
            }

            jj_consume_token(AstRegExpId.kw57);
            return el;
            //throw new Error("Missing return statement in function");
            }

        static /* final */ public AstType astType() /* throws ParseException */
        {
            ast.AstType t; AstExp e;

            jj_consume_token(AstRegExpId.kw56);
            switch ((jj_ntk == AstRegExpId.UNDEFINED) ? jj_ntk_fn() : jj_ntk)
            {
                case AstRegExpId.kwBasicType:
                    
                    jj_consume_token(AstRegExpId.kwBasicType);
                    switch ((jj_ntk == AstRegExpId.UNDEFINED)?jj_ntk_fn():jj_ntk)
                    {
                        case AstRegExpId.kwInt:
                            jj_consume_token(AstRegExpId.kwInt);
                            t = new AstBasicType(AstBasicType.Int);
                            break;

                        case AstRegExpId.kwBool:
                            jj_consume_token(AstRegExpId.kwBool);
                            t = new AstBasicType(AstBasicType.Bool);
                            break;

                        default:
                            jj_la1[6] = jj_gen;
                            jj_consume_token(AstRegExpId.UNDEFINED);
                            throw new AstParseException();
                    }
                    break;

                case AstRegExpId.kwObjType:

                    jj_consume_token(AstRegExpId.kwObjType);
                    e = astExp();
                    t = new AstObjType((AstId)e);
                    break;

                case AstRegExpId.kwArrayType:

                    jj_consume_token(AstRegExpId.kwArrayType);
                    t = astType();
                    t = new AstArrayType(t);
                    break;

                case AstRegExpId.kwNullType:

                    jj_consume_token(AstRegExpId.kwNullType);
                    t = null;
                    break;

                default:
                    jj_la1[7] = jj_gen;
                    jj_consume_token(AstRegExpId.UNDEFINED);
                    throw new AstParseException();
            }
            jj_consume_token(AstRegExpId.kw57);
            {if (true) return t;}
            throw new Error("Missing return statement in function");
        }

  static /* final */ public AstStmt astStmt() /* throws ParseException */ {
  AstExp e1, e2; AstStmt s, s1, s2; AstExpList el; AstStmtList sl;
    jj_consume_token(AstRegExpId.kw56);
    switch ((jj_ntk == AstRegExpId.UNDEFINED)?jj_ntk_fn():jj_ntk) {
    case AstRegExpId.kwBlock:
      jj_consume_token(AstRegExpId.kwBlock);
      sl = astStmtList();
                                       s = new AstBlock(sl);
      break;
    case AstRegExpId.kwAssign:
      jj_consume_token(AstRegExpId.kwAssign);
      e1 = astExp();
      e2 = astExp();
                                       s = new AstAssign(e1,e2);
      break;
    case AstRegExpId.kwCallStmt:
      jj_consume_token(AstRegExpId.kwCallStmt);
      e1 = astExp();
      e2 = astExp();
      el = astExpList();
                                       s = new AstCallStmt(e1,(AstId)e2,el);
      break;
    case AstRegExpId.kwIf:
      jj_consume_token(AstRegExpId.kwIf);
      e1 = astExp();
      s1 = astStmt();
      s2 = astStmt();
                                       s = new AstIf(e1,s1,s2);
      break;
    case AstRegExpId.kwWhile:
      jj_consume_token(AstRegExpId.kwWhile);
      e1 = astExp();
      s1 = astStmt();
                                       s = new AstWhile(e1,s1);
      break;
    case AstRegExpId.kwPrint:
      jj_consume_token(AstRegExpId.kwPrint);
      e1 = astExp();
                                       s = new AstPrint(e1);
      break;
    case AstRegExpId.kwReturn:
      jj_consume_token(AstRegExpId.kwReturn);
      e1 = astExp();
                                       s = new AstReturn(e1);
      break;
    case AstRegExpId.kwNullStmt:
      jj_consume_token(AstRegExpId.kwNullStmt);
                                       s = null;
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(AstRegExpId.UNDEFINED);
      throw new AstParseException();
    }
    jj_consume_token(AstRegExpId.kw57);
    {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

        static /* final */ public AstBinop.OP binOp() /* throws ParseException */
        {
            switch ((jj_ntk == AstRegExpId.UNDEFINED) ? jj_ntk_fn() : jj_ntk)
            {
                case AstRegExpId.kw58:
                    jj_consume_token(AstRegExpId.kw58);
                    return ast.AstBinop.OP.ADD;

                case AstRegExpId.kw59:
                    jj_consume_token(AstRegExpId.kw59);
                    return ast.AstBinop.OP.SUB;

                case AstRegExpId.kw60:
                    jj_consume_token(AstRegExpId.kw60);
                    return ast.AstBinop.OP.MUL;

                case AstRegExpId.kw61:
                    jj_consume_token(AstRegExpId.kw61);
                    return ast.AstBinop.OP.DIV;

                case AstRegExpId.kw62:
                    jj_consume_token(AstRegExpId.kw62);
                    return ast.AstBinop.OP.AND;

                case AstRegExpId.kw63:
                    jj_consume_token(AstRegExpId.kw63);
                    return ast.AstBinop.OP.OR;

                default:
                    jj_la1[9] = jj_gen;
                    jj_consume_token(AstRegExpId.UNDEFINED);
                    throw new AstParseException();
            }
            throw new Error("Missing return statement in function");
            }

        static /* final */ public AstRelop.OP relOp() /* throws ParseException */
        {
            switch ((jj_ntk == AstRegExpId.UNDEFINED) ? jj_ntk_fn() : jj_ntk)
            {
                case AstRegExpId.kw64:
                    jj_consume_token(AstRegExpId.kw64);
                    return ast.AstRelop.OP.EQ;
                case AstRegExpId.kw65:
                    jj_consume_token(AstRegExpId.kw65);
                    return ast.AstRelop.OP.NE;
                case AstRegExpId.kw66:
                    jj_consume_token(AstRegExpId.kw66);
                    return ast.AstRelop.OP.LT;
                case AstRegExpId.kw67:
                    jj_consume_token(AstRegExpId.kw67);
                    return ast.AstRelop.OP.LE;
                case AstRegExpId.kw68:
                    jj_consume_token(AstRegExpId.kw68);
                    return ast.AstRelop.OP.GT;
                case AstRegExpId.kw69:
                    jj_consume_token(AstRegExpId.kw69);
                    return ast.AstRelop.OP.GE;
                default:
                    jj_la1[10] = jj_gen;
                    jj_consume_token(AstRegExpId.UNDEFINED);
                    throw new AstParseException();
            }
            throw new Error("Missing return statement in function");
        }

        static /* final */ public ast.AstUnop.OP unOp() /* throws ParseException */
        {
            switch ((jj_ntk == AstRegExpId.UNDEFINED) ? jj_ntk_fn() : jj_ntk)
            {
                case AstRegExpId.kw59:
                    jj_consume_token(AstRegExpId.kw59);
                    return ast.AstUnop.OP.NEG;
                
                case AstRegExpId.kw70:
                    jj_consume_token(AstRegExpId.kw70);
                    return ast.AstUnop.OP.NOT;
                
                default:
                    jj_la1[11] = jj_gen;
                    jj_consume_token(AstRegExpId.UNDEFINED);
                    throw new AstParseException();
            }
            throw new Error("Missing return statement in function");
        }

        static /* final */ public AstExp astExp() /* throws ParseException */
        {
            AstType t; 
            AstToken n;
            AstRelop.OP relop;
            AstBinop.OP binop;
            AstUnop.OP unop;
            AstExp e, e1, e2; 
            AstExpList el;
            
            jj_consume_token(AstRegExpId.kw56);
    switch ((jj_ntk == AstRegExpId.UNDEFINED)?jj_ntk_fn():jj_ntk) {
    case AstRegExpId.kwArrayElm:
      jj_consume_token(AstRegExpId.kwArrayElm);
      e1 = astExp();
      e2 = astExp();
                                  e = new AstArrayElm(e1,e2);
      break;
    case AstRegExpId.kwArrayLen:
      jj_consume_token(AstRegExpId.kwArrayLen);
      e1 = astExp();
                                  e = new AstArrayLen(e1);
      break;
    case AstRegExpId.kwBinop:
      jj_consume_token(AstRegExpId.kwBinop);
      binop = binOp();
      e1 = astExp();
      e2 = astExp();
                                  e = new AstBinop(binop,e1,e2);
      break;
    case AstRegExpId.kwBoolVal:
      jj_consume_token(AstRegExpId.kwBoolVal);
      switch ((jj_ntk == AstRegExpId.UNDEFINED)?jj_ntk_fn():jj_ntk) {
      case AstRegExpId.kwTrue:
        jj_consume_token(AstRegExpId.kwTrue);
                                  e = new AstBoolVal(true);
        break;
      case AstRegExpId.kwFalse:
        jj_consume_token(AstRegExpId.kwFalse);
                                  e = new AstBoolVal(false);
        break;
      default:
        jj_la1[12] = jj_gen;
        jj_consume_token(AstRegExpId.UNDEFINED);
        throw new AstParseException();
      }
      break;
    case AstRegExpId.kwCall:
      jj_consume_token(AstRegExpId.kwCall);
      e1 = astExp();
      e2 = astExp();
      el = astExpList();
                                  e = new AstCall(e1,(AstId)e2,el);
      break;
    case AstRegExpId.kwId:
      jj_consume_token(AstRegExpId.kwId);
      n = jj_consume_token(AstRegExpId.ID);
                                  e = new AstId(n.image);
      break;
    case AstRegExpId.kwIntVal:
      jj_consume_token(AstRegExpId.kwIntVal);
      n = jj_consume_token(AstRegExpId.INTVAL);
                                  e = new AstIntVal(int.Parse(n.image));
      break;
    case AstRegExpId.kwField:
      jj_consume_token(AstRegExpId.kwField);
      e1 = astExp();
      e2 = astExp();
                                  e = new AstField(e1,(AstId)e2);
      break;
    case AstRegExpId.kwNewArray:
      jj_consume_token(AstRegExpId.kwNewArray);
      t = astType();
      n = jj_consume_token(AstRegExpId.INTVAL);
      e = new AstNewArray((AstType)t, int.Parse(n.image));
      break;
    case AstRegExpId.kwNewObj:
      jj_consume_token(AstRegExpId.kwNewObj);
      e1 = astExp();
      el = astExpList();
                                  e = new AstNewObj((AstId)e1,el);
      break;
    case AstRegExpId.kwRelop:
      jj_consume_token(AstRegExpId.kwRelop);
      relop = relOp();
      e1 = astExp();
      e2 = astExp();
      e = new AstRelop(relop, e1, e2);
      break;
    case AstRegExpId.kwStrVal:
      jj_consume_token(AstRegExpId.kwStrVal);
      n = jj_consume_token(AstRegExpId.STRVAL);
                                  String s = n.image;
                                  e = new AstStrVal(s.Substring(1, s.Length-2));
      break;
    case AstRegExpId.kwThis:
      jj_consume_token(AstRegExpId.kwThis);
                                  e = new AstThis();
      break;
    case AstRegExpId.kwUnop:
      jj_consume_token(AstRegExpId.kwUnop);
      unop = unOp();
      e1 = astExp();
                                   e = new AstUnop(unop,e1);
      break;
    case AstRegExpId.kwNullExp:
      jj_consume_token(AstRegExpId.kwNullExp);
                                  e = null;
      break;

    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(AstRegExpId.UNDEFINED);
      throw new AstParseException();
    }
    jj_consume_token(AstRegExpId.kw57);
    {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  static private bool jj_initialized_once = false;
  /** Generated Token Manager. */
  static public AstParserTokenManager token_source;
  static SimpleCharStream jj_input_stream = null;
  /** Current token. */
  static public AstToken token;
  /** Next token. */
  static public AstToken jj_nt;
  static private AstRegExpId jj_ntk;
  static private int jj_gen;
  static readonly private int[] jj_la1 = new int[14];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static AstParser() {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x8002000,0x500,0x4011200,0x0,0x0,0x0,0x200000, unchecked((int)0x9240c8c0),};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x1000000,0x1000000,0x1000000,0x1000000,0x1000000,0x1000000,0x0,0x10002,0x28024,unchecked((int)0xfc000000),0x0,0x8000000,0x400,0x41311,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3f,0x40,0x0,0x0,};
   }

  /** Constructor with InputStream. */
  public AstParser(Stream stream)
       : this(stream, Encoding.ASCII)
    {
    }
  
        /** Constructor with InputStream and supplied encoding */
        public AstParser(Stream stream, Encoding encoding)
        {
            if (jj_initialized_once)
            {
                ReInit(stream, encoding);
                //System.Out.println("ERROR: Second call to constructor of static parser.  ");
                //System.Out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
                //System.Out.println("       during parser generation.");
                //throw new Error();
            }
            else
            {
                jj_initialized_once = true;
                try 
                { 
                    jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); 
                }
                catch (UnsupportedEncodingException e)
                { 
                    throw new RuntimeException(e); 
                }
                token_source = new AstParserTokenManager(jj_input_stream);
            }

            token = new AstToken();
            jj_ntk = AstRegExpId.UNDEFINED;
            jj_gen = 0;

            for (int i = 0; i < 14; i++)
                jj_la1[i] = -1;
        }

        /** Reinitialise. */
        static public void ReInit(Stream stream)
        {
            ReInit(stream, Encoding.ASCII);
        }

        /** Reinitialise. */
        static public void ReInit(Stream stream, Encoding encoding)
        {
            try 
            { 
                jj_input_stream.ReInit(stream, encoding, 1, 1); 
            } 
            catch(UnsupportedEncodingException e) 
            { 
                throw new RuntimeException(e); 
            }
            AstParserTokenManager.ReInit(jj_input_stream);
            token = new AstToken();
            jj_ntk = AstRegExpId.UNDEFINED;
            jj_gen = 0;
            for (int i = 0; i < 14; i++) jj_la1[i] = -1;
        }

#if false
  /** Constructor. */
  public astParser(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.Out.println("ERROR: Second call to constructor of static parser. ");
      System.Out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.Out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new astParserTokenManager(jj_input_stream);
    token = new AstToken();
    jj_ntk = AstRegExpId.UNDEFINED;
    jj_gen = 0;
    for (int i = 0; i < 14; i++) jj_la1[i] = -1;
  }

        /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new AstToken();
    jj_ntk = AstRegExpId.UNDEFINED;
    jj_gen = 0;
    for (int i = 0; i < 14; i++) jj_la1[i] = -1;
  }
        /** Constructor with generated Token Manager. */
        public astParser(astParserTokenManager tm)
        {
            if (jj_initialized_once)
            {
                System.Out.println("ERROR: Second call to constructor of static parser. ");
                System.Out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
                System.Out.println("       during parser generation.");
                throw new Error();
            }
            jj_initialized_once = true;
            token_source = tm;
            token = new AstToken();
            jj_ntk = AstRegExpId.UNDEFINED;
            jj_gen = 0;
            for (int i = 0; i < 14; i++)
                jj_la1[i] = -1;
        }
        /** Reinitialise. */
        public void ReInit(astParserTokenManager tm)
        {
            token_source = tm;
            token = new AstToken();
            jj_ntk = AstRegExpId.UNDEFINED;
            jj_gen = 0;
            for (int i = 0; i < 14; i++)
                jj_la1[i] = -1;
        }
#endif

        static private AstToken jj_consume_token(AstParserConstants.AstRegExpId kind) /* throws ParseException */
        {
            AstToken oldToken;
            if ((oldToken = token).next != null) 
                token = token.next;
            else
                token = token.next = AstParserTokenManager.getNextToken();
            jj_ntk = AstRegExpId.UNDEFINED;

            if (token.kind == kind)
            {
                jj_gen++;
                return token;
            }
            token = oldToken;
            jj_kind = kind;
            throw generateParseException();
        }

        /** Get the next Token. */
        static /* final */ public AstToken getNextToken()
        {
            if (token.next != null) 
                token = token.next;
            else
                token = token.next = AstParserTokenManager.getNextToken();
            jj_ntk = AstRegExpId.UNDEFINED;
            jj_gen++;
            return token;
        }

        /** Get the specific Token. */
        static /* final */ public AstToken getToken(int index)
        {
            AstToken t = token;
            for (int i = 0; i < index; i++)
            {
                if (t.next != null)
                    t = t.next;
                else 
                    t = t.next = AstParserTokenManager.getNextToken();
            }
            return t;
        }

        static private AstRegExpId jj_ntk_fn()
        {
            if ((jj_nt=token.next) == null)
                return (jj_ntk = (token.next = AstParserTokenManager.getNextToken()).kind);
            else
                return (jj_ntk = jj_nt.kind);
        }

        //private static java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
        private static List<int[]> jj_expentries = new List<int[]>();
        static private int[] jj_expentry;
        static private AstRegExpId jj_kind = AstRegExpId.UNDEFINED;

        /** Generate ParseException. */
        static public AstParseException generateParseException()
        {
            jj_expentries.Clear();
            bool[] la1tokens = new bool[71];
            if (jj_kind >= 0)
            {
                la1tokens[(int)jj_kind] = true;
                jj_kind = AstRegExpId.UNDEFINED;
            }
            for (int i = 0; i < 14; i++)
            {
                if (jj_la1[i] == jj_gen)
                {
                    for (int j = 0; j < 32; j++)
                    {
                        if ((jj_la1_0[i] & (1<<j)) != 0)
                        {
                            la1tokens[j] = true;
                        }
                        if ((jj_la1_1[i] & (1<<j)) != 0)
                        {
                            la1tokens[32+j] = true;
                        }
                        if ((jj_la1_2[i] & (1<<j)) != 0)
                        {
                            la1tokens[64+j] = true;
                        }
                    }
                }
            }
            for (int i = 0; i < 71; i++)
            {
                if (la1tokens[i])
                {
                    jj_expentry = new int[1];
                    jj_expentry[0] = i;
                    jj_expentries.Add(jj_expentry);
                }
            }
            int[][] exptokseq = new int[jj_expentries.Count][];
            for (int i = 0; i < jj_expentries.Count; i++)
            {
                exptokseq[i] = jj_expentries[i];
            }
            return new AstParseException(token, exptokseq, tokenImage);
        }

        /** Enable tracing. */
        static /* final */ public void enable_tracing()
        {
        }

        /** Disable tracing. */
        static /* final */ public void disable_tracing()
        {
        }
    }
}